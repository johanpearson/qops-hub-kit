# @qops/hub-kit

A lightweight utility package for creating Azure Function v4 APIs with TypeScript. Eliminates boilerplate for JWT authentication, request validation, error handling, and OpenAPI documentation.

## Features

âœ… **Simple Handler Wrapper** - Single function that handles all middleware  
âœ… **JWT Authentication** - Built-in token verification with role-based access control  
âœ… **Request Validation** - Type-safe validation using Zod schemas  
âœ… **Error Handling** - Consistent error responses with HTTP status mapping  
âœ… **Correlation IDs** - Automatic request tracking for distributed tracing  
âœ… **OpenAPI Support** - Generate OpenAPI v3 documentation from Zod schemas  
âœ… **Health Check Endpoint** - Ready-to-use health check handler

---

## Quick Start

### Installation

```bash
npm install @qops/hub-kit zod jsonwebtoken @azure/functions
npm install -D @types/jsonwebtoken typescript
```

### Basic Example with OpenAPI

Create a simple API with authentication and OpenAPI documentation:

**1. Create a handler with validation:**

```typescript
// functions/create-user.ts
import { app } from '@azure/functions';
import { createHandler, UserRole, z } from '@qops/hub-kit';

const createUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1),
});

const handler = createHandler(
  async (request, context, { body, user }) => {
    // body is validated and typed
    const newUser = await createUser(body);
    return { status: 201, jsonBody: newUser };
  },
  {
    bodySchema: createUserSchema,
    jwtConfig: { secret: process.env.JWT_SECRET! },
    requiredRoles: [UserRole.ADMIN],
    enableLogging: true,
  }
);

app.http('createUser', {
  methods: ['POST'],
  authLevel: 'anonymous',
  route: 'users',
  handler,
});
```

**2. Add OpenAPI documentation:**

```typescript
// functions/openapi.ts
import { app } from '@azure/functions';
import { OpenApiBuilder, z } from '@qops/hub-kit';

const createUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1),
});

const userResponseSchema = z.object({
  id: z.string(),
  email: z.string(),
  name: z.string(),
  role: z.enum(['admin', 'member']),
});

const builder = new OpenApiBuilder({
  title: 'My API',
  version: '1.0.0',
  description: 'Azure Functions API with JWT authentication',
});

builder.registerRoute({
  method: 'POST',
  path: '/api/users',
  summary: 'Create user',
  tags: ['Users'],
  requestBody: createUserSchema,
  responses: {
    201: {
      description: 'User created',
      schema: userResponseSchema,
    },
  },
  requiresAuth: true,
});

app.http('openapi', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'openapi.json',
  handler: async () => ({
    status: 200,
    jsonBody: builder.generateDocument(),
  }),
});
```

**3. Test your API:**

```bash
# Build and run
npm run build
func start

# View OpenAPI docs
curl http://localhost:7071/api/openapi.json

# Test endpoint
curl -X POST http://localhost:7071/api/users \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","name":"John Doe"}'
```

---

## Complete Setup Guide

For a complete step-by-step guide including project structure, configuration files, service layer patterns, and all function handlers, see:

ðŸ‘‰ **[Getting Started Guide](./docs/GETTING-STARTED.md)**

---

## Core Features

### 1. Health Check (No Configuration Needed)

```typescript
import { app } from '@azure/functions';
import { createHealthHandler } from '@qops/hub-kit';

app.http('health', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'health',
  handler: createHealthHandler(),
});
```

### 2. Request Validation with Zod

```typescript
import { createHandler, z } from '@qops/hub-kit';

const schema = z.object({
  email: z.string().email(),
  age: z.number().int().min(18),
});

const handler = createHandler(
  async (request, context, { body }) => {
    // body is fully validated and typed
    return { status: 200, jsonBody: body };
  },
  { bodySchema: schema }
);
```

### 3. JWT Authentication & Authorization

```typescript
import { createHandler, UserRole } from '@qops/hub-kit';

const handler = createHandler(
  async (request, context, { user }) => {
    // user contains: { sub, email, name, role }
    return { status: 200, jsonBody: { userId: user.sub } };
  },
  {
    jwtConfig: { secret: process.env.JWT_SECRET! },
    requiredRoles: [UserRole.ADMIN], // or [UserRole.MEMBER]
  }
);
```

### 4. OpenAPI Documentation

```typescript
import { OpenApiBuilder, z } from '@qops/hub-kit';

const builder = new OpenApiBuilder({
  title: 'My API',
  version: '1.0.0',
});

builder.registerRoute({
  method: 'GET',
  path: '/api/users/{id}',
  summary: 'Get user by ID',
  tags: ['Users'],
  responses: {
    200: { description: 'User found', schema: userSchema },
    404: { description: 'User not found' },
  },
  requiresAuth: true,
});

const openApiDoc = builder.generateDocument();
```

### 5. Error Handling

```typescript
import { AppError, ErrorCode } from '@qops/hub-kit';

// Throw errors anywhere in your code
throw new AppError(ErrorCode.NOT_FOUND, 'User not found');
throw new AppError(ErrorCode.UNAUTHORIZED, 'Invalid credentials');
throw new AppError(ErrorCode.VALIDATION_ERROR, 'Invalid email', { field: 'email' });

// Automatic HTTP status mapping:
// BAD_REQUEST â†’ 400, UNAUTHORIZED â†’ 401, FORBIDDEN â†’ 403
// NOT_FOUND â†’ 404, CONFLICT â†’ 409, VALIDATION_ERROR â†’ 422
// INTERNAL_ERROR â†’ 500
```

### 6. Correlation IDs (Automatic)

Every request automatically gets a correlation ID for distributed tracing:

```typescript
const handler = createHandler(
  async (request, context, { correlationId }) => {
    console.log(`[${correlationId}] Processing request`);
    return { status: 200, jsonBody: { correlationId } };
  },
  { enableLogging: true }
);
// Response includes X-Correlation-ID header
```

---

## Documentation

### ðŸ“š Detailed Guides

- **[Getting Started](./docs/GETTING-STARTED.md)** - Complete setup guide with all configuration files
- **[Advanced Usage](./docs/ADVANCED.md)** - Complex validation, RBAC, testing, and best practices
- **[Azure Integrations](./docs/INTEGRATIONS.md)** - Cosmos DB, Blob Storage, Service Bus, Key Vault, and more

### ðŸ“– API Reference

#### Handler Options

```typescript
interface HandlerOptions {
  bodySchema?: ZodSchema;        // Validate request body
  querySchema?: ZodSchema;       // Validate query parameters
  jwtConfig?: {
    secret: string;              // JWT secret key
    algorithms?: string[];       // Default: ['HS256']
  };
  requiredRoles?: UserRole[];    // Require specific roles
  enableLogging?: boolean;       // Log requests/responses
}
```

#### Handler Context

```typescript
async (request, context, enrichedContext) => {
  const {
    body,          // Validated body (if bodySchema provided)
    query,         // Validated query params (if querySchema provided)
    user,          // JWT payload (if jwtConfig provided)
    correlationId, // Unique request ID
  } = enrichedContext;
};
```

#### Error Codes

- `BAD_REQUEST` (400)
- `UNAUTHORIZED` (401)
- `FORBIDDEN` (403)
- `NOT_FOUND` (404)
- `CONFLICT` (409)
- `VALIDATION_ERROR` (422)
- `INTERNAL_ERROR` (500)

---

## Best Practices

1. **Always use OpenAPI** - Document all endpoints for better API discoverability and testing
2. **Service Layer Pattern** - Keep business logic separate from handlers
3. **Input Validation** - Use Zod schemas for all user input
4. **Error Handling** - Use `AppError` for consistent error responses
5. **JWT Claims** - Always include `sub`, `email`, `name`, and `role` in tokens
6. **Environment Variables** - Store secrets in environment variables, never in code

---

## Development

```bash
# Install dependencies
npm install

# Build
npm run build

# Run tests
npm test

# Run tests with coverage
npm run test:coverage

# Lint
npm run lint

# Format
npm run format
```

---

## Environment Variables

Required for JWT authentication:

```env
JWT_SECRET=your-secret-key-here
FUNCTIONS_WORKER_RUNTIME=node
```

For Azure service integrations, see [Azure Integrations Guide](./docs/INTEGRATIONS.md).

---

## Contributing

Contributions are welcome! Please ensure:
- All tests pass (`npm test`)
- Code coverage â‰¥ 80% (`npm run test:coverage`)
- Code is formatted (`npm run format`)
- No linting errors (`npm run lint`)

---

## License

MIT

---

## Links

- **Repository**: [github.com/johanpearson/qops-hub-kit](https://github.com/johanpearson/qops-hub-kit)
- **Issues**: [Report bugs or request features](https://github.com/johanpearson/qops-hub-kit/issues)
- **Author**: Johan Pearson

```ini
# .npmrc
@qops:registry=https://your-private-registry.com/
//your-private-registry.com/:_authToken=${NPM_TOKEN}
```

### 2. Install Dependencies

```bash
npm init -y
npm install @qops/hub-kit zod jsonwebtoken @azure/functions
npm install -D @types/node @types/jsonwebtoken typescript @azure/functions
```

### 3. Project Structure

Here's a recommended project structure:

```
my-api/
â”œâ”€â”€ .npmrc                          # Private registry configuration
â”œâ”€â”€ package.json                    # Dependencies and scripts
â”œâ”€â”€ tsconfig.json                   # TypeScript configuration
â”œâ”€â”€ host.json                       # Azure Functions configuration
â”œâ”€â”€ local.settings.json             # Environment variables (local)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ services/                   # Business logic
â”‚   â”‚   â””â”€â”€ user.service.ts
â”‚   â””â”€â”€ functions/                  # Azure Function handlers
â”‚       â”œâ”€â”€ login.ts
â”‚       â”œâ”€â”€ get-user.ts
â”‚       â””â”€â”€ list-users.ts
â””â”€â”€ README.md
```

### 4. Configuration Files

**tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022"],
    "moduleResolution": "node",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**package.json** (add these scripts)

```json
{
  "type": "module",
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch",
    "clean": "rimraf dist"
  }
}
```

**host.json**

```json
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "maxTelemetryItemsPerSecond": 20
      }
    }
  },
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[4.*, 5.0.0)"
  }
}
```

**local.settings.json**

```json
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "node",
    "JWT_SECRET": "your-secret-key-change-this-in-production"
  }
}
```

### 5. Service Layer (Business Logic)

**src/services/user.service.ts**

```typescript
import { AppError, ErrorCode } from '@qops/hub-kit';
import { randomUUID } from 'node:crypto';

export interface User {
  id: string;
  email: string;
  name: string;
  passwordHash: string;
  role: 'admin' | 'member';
}

export interface UserResponse {
  id: string;
  email: string;
  name: string;
  role: string;
}

// In-memory storage (use a real database in production)
const users = new Map<string, User>();
const emailIndex = new Map<string, string>();

// Seed data
const adminUser: User = {
  id: randomUUID(),
  email: 'admin@example.com',
  name: 'Admin User',
  passwordHash: 'hashed_admin_password', // Use bcrypt in production
  role: 'admin',
};
users.set(adminUser.id, adminUser);
emailIndex.set(adminUser.email, adminUser.id);

export async function authenticateUser(email: string, password: string): Promise<UserResponse> {
  const userId = emailIndex.get(email);
  if (!userId) {
    throw new AppError(ErrorCode.UNAUTHORIZED, 'Invalid credentials');
  }

  const user = users.get(userId);
  if (!user || user.passwordHash !== `hashed_${password}`) {
    throw new AppError(ErrorCode.UNAUTHORIZED, 'Invalid credentials');
  }

  return {
    id: user.id,
    email: user.email,
    name: user.name,
    role: user.role,
  };
}

export async function getUserById(id: string): Promise<UserResponse> {
  const user = users.get(id);
  if (!user) {
    throw new AppError(ErrorCode.NOT_FOUND, 'User not found');
  }

  return {
    id: user.id,
    email: user.email,
    name: user.name,
    role: user.role,
  };
}

export async function getAllUsers(): Promise<UserResponse[]> {
  return Array.from(users.values()).map((user) => ({
    id: user.id,
    email: user.email,
    name: user.name,
    role: user.role,
  }));
}
```

### 6. Function Handlers

**src/functions/login.ts**

```typescript
import { app } from '@azure/functions';
import { createHandler, z } from '@qops/hub-kit';
import jwt from 'jsonwebtoken';
import { authenticateUser } from '../services/user.service.js';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

const loginHandler = createHandler(
  async (request, context, { body }) => {
    const user = await authenticateUser(body.email, body.password);

    const token = jwt.sign(
      {
        sub: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
      },
      process.env.JWT_SECRET!,
      { expiresIn: '24h' },
    );

    return {
      status: 200,
      jsonBody: { token, user },
    };
  },
  {
    bodySchema: loginSchema,
    enableLogging: true,
  },
);

app.http('login', {
  methods: ['POST'],
  authLevel: 'anonymous',
  route: 'auth/login',
  handler: loginHandler,
});
```

**src/functions/get-user.ts**

```typescript
import { app } from '@azure/functions';
import { createHandler, UserRole } from '@qops/hub-kit';
import { getUserById } from '../services/user.service.js';

const getUserHandler = createHandler(
  async (request, context, { user }) => {
    const userId = request.params.id;
    const userData = await getUserById(userId);

    return {
      status: 200,
      jsonBody: userData,
    };
  },
  {
    jwtConfig: { secret: process.env.JWT_SECRET! },
    requiredRoles: [UserRole.MEMBER],
    enableLogging: true,
  },
);

app.http('getUser', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'users/{id}',
  handler: getUserHandler,
});
```

**src/functions/list-users.ts**

```typescript
import { app } from '@azure/functions';
import { createHandler, UserRole } from '@qops/hub-kit';
import { getAllUsers } from '../services/user.service.js';

const listUsersHandler = createHandler(
  async (request, context, { user }) => {
    const users = await getAllUsers();

    return {
      status: 200,
      jsonBody: { users, total: users.length },
    };
  },
  {
    jwtConfig: { secret: process.env.JWT_SECRET! },
    requiredRoles: [UserRole.MEMBER],
    enableLogging: true,
  },
);

app.http('listUsers', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'users',
  handler: listUsersHandler,
});
```

**src/functions/health.ts**

```typescript
import { app } from '@azure/functions';
import { createHealthHandler } from '@qops/hub-kit';

// Simple health check endpoint - no configuration needed!
app.http('health', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'health',
  handler: createHealthHandler(),
});
```

### 7. OpenAPI Documentation (Optional)

Add an OpenAPI endpoint to document your API:

**src/functions/openapi.ts**

```typescript
import { app } from '@azure/functions';
import { OpenApiBuilder, healthCheckResponseSchema } from '@qops/hub-kit';
import { z } from 'zod';

// Define your schemas
const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

const userResponseSchema = z.object({
  id: z.string(),
  email: z.string(),
  name: z.string(),
  role: z.enum(['admin', 'member']),
});

const loginResponseSchema = z.object({
  token: z.string(),
  user: userResponseSchema,
});

const usersListSchema = z.object({
  users: z.array(userResponseSchema),
  total: z.number(),
});

// Build OpenAPI documentation
const builder = new OpenApiBuilder({
  title: 'My API',
  version: '1.0.0',
  description: 'Azure Functions API with JWT authentication',
});

builder.registerRoute({
  method: 'POST',
  path: '/api/auth/login',
  summary: 'User login',
  description: 'Authenticate user and return JWT token',
  tags: ['Authentication'],
  requestBody: loginSchema,
  responses: {
    200: {
      description: 'Login successful',
      schema: loginResponseSchema,
    },
    401: {
      description: 'Invalid credentials',
    },
  },
  requiresAuth: false,
});

builder.registerRoute({
  method: 'GET',
  path: '/api/users/{id}',
  summary: 'Get user by ID',
  description: 'Retrieve a user by their ID',
  tags: ['Users'],
  parameters: [
    {
      name: 'id',
      in: 'path',
      required: true,
      schema: z.string(),
      description: 'User ID',
    },
  ],
  responses: {
    200: {
      description: 'User found',
      schema: userResponseSchema,
    },
    404: {
      description: 'User not found',
    },
  },
  requiresAuth: true,
});

builder.registerRoute({
  method: 'GET',
  path: '/api/users',
  summary: 'List all users',
  description: 'Retrieve all users',
  tags: ['Users'],
  responses: {
    200: {
      description: 'List of users',
      schema: usersListSchema,
    },
  },
  requiresAuth: true,
});

// Optional: Register health check endpoint
builder.registerRoute({
  method: 'GET',
  path: '/api/health',
  summary: 'Health check',
  description: 'Check API health status',
  tags: ['Health'],
  responses: {
    200: {
      description: 'Service is healthy',
      schema: healthCheckResponseSchema,
    },
  },
  requiresAuth: false,
});

// Generate and serve OpenAPI document
app.http('openapi', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'openapi.json',
  handler: async (request, context) => {
    return {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      jsonBody: builder.generateDocument(),
    };
  },
});
```

You can now access your API documentation at `http://localhost:7071/api/openapi.json` and use it with tools like Swagger UI or Postman.

### 8. Test Your API

```bash
# Build
npm run build

# Start Azure Functions locally
func start

# Test health endpoint (no auth required)
curl http://localhost:7071/api/health

# Response: { "status": "healthy", "timestamp": "2024-01-08T19:00:00.000Z", "uptime": 123.45 }

# Test login
curl -X POST http://localhost:7071/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"admin_password"}'

# Response: { "token": "eyJhbGc...", "user": {...} }

# Test protected endpoint
curl http://localhost:7071/api/users \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"
```

That's it! You now have a working Azure Functions API with authentication, validation, and error handling.

---

## Configuring Base URL and Route Prefix

The base URL for Azure Functions is controlled by the Azure Functions runtime, not by this package.

### Local Development

- **Default**: `http://localhost:7071/api/{function-name}`
- **Port**: Configure in `local.settings.json` via `Host.LocalHttpPort` (defaults to 7071)
- **Route Prefix**: The `/api` prefix is set in `host.json`

### Azure (Production)

- **Default**: `https://{function-app-name}.azurewebsites.net/api/{function-name}`
- **Custom Domains**: Configure in Azure Portal under Custom domains

### Customizing the Route Prefix

To change the `/api` prefix (or remove it entirely), add this to your `host.json`:

```json
{
  "version": "2.0",
  "extensions": {
    "http": {
      "routePrefix": "v1" // Changes /api to /v1
      // or use "" to remove the prefix entirely
    }
  }
}
```

**Examples:**

- `"routePrefix": "v1"` â†’ `http://localhost:7071/v1/auth/login`
- `"routePrefix": ""` â†’ `http://localhost:7071/auth/login`
- `"routePrefix": "api/v2"` â†’ `http://localhost:7071/api/v2/auth/login`

The function route paths (e.g., `auth/login`, `users/{id}`) are defined when you register handlers in your function configuration using the `route` property.

---

## Installation

```bash
npm install @qops/hub-kit zod jsonwebtoken
npm install -D @types/jsonwebtoken
```

## API Reference

### Basic Handler (No Auth)

```typescript
// functions/hello.ts
import { createHandler, z } from '@qops/hub-kit';

const schema = z.object({
  name: z.string().min(1),
});

export default createHandler(
  async (request, context, { body }) => {
    return {
      status: 200,
      jsonBody: { message: `Hello, ${body.name}!` },
    };
  },
  {
    bodySchema: schema,
    enableLogging: true,
  },
);
```

### Protected Handler (With JWT Auth)

```typescript
// functions/get-user.ts
import { createHandler, UserRole } from '@qops/hub-kit';

export default createHandler(
  async (request, context, { user }) => {
    const userId = request.params.id;
    // Fetch user from database
    const userData = await getUserById(userId);

    return { status: 200, jsonBody: userData };
  },
  {
    jwtConfig: { secret: process.env.JWT_SECRET! },
    requiredRoles: [UserRole.MEMBER], // or [UserRole.ADMIN]
    enableLogging: true,
  },
);
```

### Login Handler (Generate JWT)

```typescript
// functions/login.ts
import { createHandler, z } from '@qops/hub-kit';
import jwt from 'jsonwebtoken';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

export default createHandler(
  async (request, context, { body }) => {
    // Verify credentials (from database)
    const user = await authenticateUser(body.email, body.password);

    // Generate JWT with required claims
    const token = jwt.sign(
      {
        sub: user.id,
        email: user.email,
        name: user.name,
        role: user.role, // 'admin' or 'member'
      },
      process.env.JWT_SECRET!,
      { expiresIn: '24h' },
    );

    return { status: 200, jsonBody: { token, user } };
  },
  {
    bodySchema: loginSchema,
    enableLogging: true,
  },
);
```

### Health Check Handler

```typescript
// functions/health.ts
import { app } from '@azure/functions';
import { createHealthHandler } from '@qops/hub-kit';

// Ready-to-use health check endpoint - no configuration needed!
app.http('health', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'health',
  handler: createHealthHandler(),
});

// Response:
// {
//   "status": "healthy",
//   "timestamp": "2024-01-08T19:00:00.000Z",
//   "uptime": 123.45
// }
```

The health check handler:

- Returns a simple status response
- Includes current timestamp in ISO 8601 format
- Reports process uptime in seconds
- Automatically adds correlation ID header
- Requires no configuration or authentication

**OpenAPI Schema**: Use `healthCheckResponseSchema` to document the health endpoint in your OpenAPI specification:

```typescript
import { OpenApiBuilder, healthCheckResponseSchema } from '@qops/hub-kit';

builder.registerRoute({
  method: 'GET',
  path: '/api/health',
  summary: 'Health check',
  tags: ['Health'],
  responses: {
    200: {
      description: 'Service is healthy',
      schema: healthCheckResponseSchema,
    },
  },
  requiresAuth: false,
});
```

## Handler Options

```typescript
interface HandlerOptions {
  // Request validation
  bodySchema?: ZodSchema; // Validate request body
  querySchema?: ZodSchema; // Validate query parameters

  // Authentication
  jwtConfig?: {
    secret: string; // JWT secret key
    algorithms?: string[]; // Default: ['HS256']
  };
  requiredRoles?: UserRole[]; // Require specific roles

  // Other
  enableLogging?: boolean; // Log requests/responses
}
```

## Handler Context

The handler function receives enriched context:

```typescript
async (request, context, enrichedContext) => {
  // enrichedContext includes:
  const {
    body, // Validated request body (if bodySchema provided)
    query, // Validated query params (if querySchema provided)
    user, // JWT payload (if jwtConfig provided): { sub, email, name, role }
    correlationId, // Unique ID for request tracking
  } = enrichedContext;
};
```

## Error Handling

Use `AppError` for consistent error responses:

```typescript
import { AppError, ErrorCode } from '@qops/hub-kit';

// Throw errors anywhere in your code
throw new AppError(ErrorCode.NOT_FOUND, 'User not found');
throw new AppError(ErrorCode.UNAUTHORIZED, 'Invalid credentials');
throw new AppError(ErrorCode.BAD_REQUEST, 'Invalid input', { field: 'email' });

// Available error codes:
// - BAD_REQUEST (400)
// - UNAUTHORIZED (401)
// - FORBIDDEN (403)
// - NOT_FOUND (404)
// - CONFLICT (409)
// - VALIDATION_ERROR (422)
// - INTERNAL_ERROR (500)
```

## Integration Examples

### Azure Cosmos DB

```typescript
// services/user.service.ts
import { CosmosClient } from '@azure/cosmos';
import { AppError, ErrorCode } from '@qops/hub-kit';

const client = new CosmosClient({
  endpoint: process.env.COSMOS_ENDPOINT!,
  key: process.env.COSMOS_KEY!,
});

const container = client.database('mydb').container('users');

export async function getUserById(id: string) {
  try {
    const { resource } = await container.item(id, id).read();
    return resource;
  } catch (error: any) {
    if (error.code === 404) {
      throw new AppError(ErrorCode.NOT_FOUND, 'User not found');
    }
    throw new AppError(ErrorCode.INTERNAL_ERROR, 'Database error');
  }
}
```

### Azure Blob Storage

```typescript
// services/file.service.ts
import { BlobServiceClient } from '@azure/storage-blob';
import { AppError, ErrorCode } from '@qops/hub-kit';

const blobServiceClient = BlobServiceClient.fromConnectionString(process.env.AZURE_STORAGE_CONNECTION_STRING!);
const containerClient = blobServiceClient.getContainerClient('uploads');

export async function uploadFile(buffer: Buffer, fileName: string) {
  try {
    const blobClient = containerClient.getBlockBlobClient(fileName);
    await blobClient.upload(buffer, buffer.length);
    return blobClient.url;
  } catch (error: any) {
    throw new AppError(ErrorCode.INTERNAL_ERROR, 'Upload failed');
  }
}

// Handler for file upload (no bodySchema for custom parsing)
export default createHandler(
  async (request, context, { user }) => {
    const body = await request.json();
    const fileBuffer = Buffer.from(body.data, 'base64');

    const url = await uploadFile(fileBuffer, body.filename);
    return { status: 201, jsonBody: { url } };
  },
  {
    jwtConfig: { secret: process.env.JWT_SECRET! },
    requiredRoles: [UserRole.MEMBER],
    // No bodySchema - allows manual body parsing
  },
);
```

## OpenAPI Documentation

Generate OpenAPI v3 documentation:

```typescript
import { OpenApiBuilder, z } from '@qops/hub-kit';

const builder = new OpenApiBuilder({
  title: 'My API',
  version: '1.0.0',
  description: 'API documentation',
});

// Register routes
builder.registerRoute({
  method: 'POST',
  path: '/api/users',
  summary: 'Create user',
  requestBody: z.object({
    email: z.string().email(),
    name: z.string(),
  }),
  responses: {
    201: {
      description: 'User created',
      schema: z.object({
        id: z.string(),
        email: z.string(),
        name: z.string(),
      }),
    },
  },
  requiresAuth: true,
});

// Generate OpenAPI document
const openApiDoc = builder.generateDocument();

// Serve it
export default createHandler(async () => ({ status: 200, jsonBody: openApiDoc }), { enableLogging: false });
```

## Environment Variables

Required environment variables:

```env
JWT_SECRET=your-secret-key-here
FUNCTIONS_WORKER_RUNTIME=node
```

Optional (for examples above):

```env
COSMOS_ENDPOINT=https://your-account.documents.azure.com:443/
COSMOS_KEY=your-cosmos-key
AZURE_STORAGE_CONNECTION_STRING=DefaultEndpointsProtocol=https;AccountName=...
```

## Best Practices

1. **Service Layer**: Keep business logic in service files, separate from handlers
2. **Error Handling**: Use `AppError` for consistent error responses
3. **Environment Variables**: Store secrets in environment variables
4. **JWT Claims**: Always include `sub`, `email`, `name`, and `role` in JWT tokens
5. **Validation**: Use Zod schemas for all user input
6. **Testing**: Service functions are easy to unit test independently

## Development

```bash
# Install dependencies
npm install

# Build
npm run build

# Run tests
npm test

# Run tests with coverage
npm run test:coverage

# Lint
npm run lint

# Format
npm run format
```

## License

MIT
